# 问题 A: 本质不同的子串

#### 题目描述

​       mfc是一个很优秀的同学，他学习认真，经常刷题。这天，他正好学习到了字符串的相关知识。为了巩固知识，他在网上找到了这样一个题目：给定n(n<=10)个字符串环，每个字符串的长度为m(m<=500)，求出每个字符串环有多少个本质不同的子串（两个字符串不相同则认为本质不同）。

​       求解本质不同的子串是一个经典的问题，mfc提出了三种效率不同的做法，最简单但是最慢的方法mfc不屑于去讲（你可以去写），当然你也可以使用字典树来记录所有的子串，时间复杂度O(m^2)，如果你也想像m队长一样厉害，也可以学习后缀自动机来求解该问题，时间复杂度O(m)。如果你可以使用效率较高的程序来解决这个问题，就可以到acm实验室与m队长一较高下！

#### 输入

> 一共有n+1行输入
>
> 第一行输入n，表示测试实例的个数
>
> 接下来的n行，每行包括一个测试实例

#### 输出

> 对于每个测试实例，输出该字符串环中本质不同的子串个数，每个输出占一行。

#### 样例输入 复制

```plain
2
aaa
abc
```

#### 样例输出 复制

```plain
3
9
```

#### 提示

> 字符串环是指一种形成环的字符串，例如abc，字符a后面跟着b，b后面跟着c，c后面跟着a。如下图所示
>
> ![img](http://xjudge.online/upload/tjuacm.chaosheng.top/image/20221202/20221202230513_20658.png)
>
> 对于第一个测试实例aaa，它有a，aa，aaa三个本质不同的子串。
>
> 对于第二个测试实例abc，它有a，b，c，ab，bc，ca，abc，bca，cab九个本质不同的子串。





# 问题 B: TJU成绩排序

#### 题目描述

​        TJU某个学院的大一新生在本学期修了五门课程，这五门课程分别有着相应的学分，现在辅导员想要在学期结束时计算自己所带的N个学生在本学期的加权成绩并对加权成绩进行排序（如遇加权成绩相同的情况，那么按照从学分高的课程到学分低的课程，依次比较单科成绩，单科成绩高的同学靠前）。

​        例如：假设5门课的学分依次为6、5、3、2、1；mfc同学的成绩分别是90、80、90、92、90，mdz同学的成绩分别是90、80、90、90，94。显然两个同学的加权成绩是一样的，同时两个同学学分为6、5、3的三门课程成绩都相同，但mfc同学在学分为2的课程中，成绩优于mdz同学，故mfc同学的排名略优于mdz同学。

​        再了解了具体的规则后，身为计算机专业的学生，你能够帮助该辅导员处理该问题吗？

​        加权成绩 S=Σi=15si∗piΣj=15pj (其中s代表对应科目成绩，p代表该科目对应学分，Σj=15pj  代表5门课程的总学分)。

#### 输入

> 输入第一行，5个数表示五门课分别的学分
>
> 第二行一个数n，代表n个学生，保证 n<= 10,000
>
> 接下来n行，每行输入一个字符串和5个整数，表示学生姓名和对应5门课的分数。

#### 输出

> 输出n行，按照题目要求排序，每行输出对应结果。
>
> 结果包括排在这一名次的同学的 姓名 加权成绩，加权成绩保留2位小数。

#### 样例输入 复制

```plain
6 5 3 2 1
10
student1 98 97 62 91 74
student2 78 63 76 63 98
student3 80 97 66 62 95
student4 74 61 81 73 92
student5 85 76 87 94 67
student6 87 65 84 79 69
student7 61 88 89 71 95
student8 83 80 79 63 98
student9 70 61 94 80 85
student10 88 76 67 94 79
```

#### 样例输出 复制

```plain
student1 89.12
student5 82.71
student3 81.29
student10 80.94
student8 79.94
student6 78.00
student7 77.06
student9 73.65
student2 72.65
student4 72.35
```





# 问题 C: 时间计算器

#### 题目描述

mfc是一个很优秀的同学，他学习认真，经常刷题。这天m队长发现了time()函数，time()函数返回一个整数，表示从1970年1月1日0时0分0秒到运行这一程序经过的秒数，当然关于求当前时刻还有很多相关的函数等待你去发现。

现在m队长想要创建自己的mfc_time函数，mfc_time()表示自某个时刻开始经过t秒之后的时刻，例如2000年1月1日0时0分0秒经过3600秒之后的时刻为2000年1月1日1时0分0秒，我们以标准日期的形式进行输出，月，日，时间，年份。详细输出规则见输入输出样例。

#### 输入

第一行输出一个数字n，表示有n组测试数据。接下来n行，每行7个整数，前六个整数表示一个时刻（年月日时分秒），最后一个整数t，表示从这个时刻开始经过了t秒。

#### 输出

输出n行，每行输出一个时刻（年月日时分秒），标准日期格式，详细格式参考输入输出样例。

#### 样例输入 复制

```plain
3
2000 1 1 0 0 0 3600
2000 2 28 23 59 59 1
2000 1 1 0 0 0 123456789
```

#### 样例输出 复制

```plain
Jan 1th 01:00:00 2000
Feb 29th 00:00:00 2000
Nov 29th 21:33:09 2003
```

#### 提示

数据1:2000年1月1日0时0分0秒经过3600秒以后是2000年1月1日1时0分0秒

数据2:2000年2月28日23时59分59秒经过1秒以后是2000年2月29日0时0分0秒，因为2000年是闰年。

我们保证读入的初始时间是合法的，年份在公元1000年到公元2022年之间。经过秒数t<=10^10。







# 问题 D: 对称图形

#### 题目描述

> mfc同学喜欢对称图形，他觉得对称图形非常的优美。

> 现在给你一张白纸（我们可以理解为空格字符），白纸上面画着一个由非空格字符组成的图形。mfc同学希望你能帮他判断，这个图形是否是一个对称图形。

> 如果该图形是一个沿平行于**Y轴对称**的图形，那么mfc会获得+1的好感度；
>
> 如果该图形是一个沿平行于**X轴对称**的图形，那么mfc会获得+2的好感度；
>
> 如果该图形是一个**中心对称**的图形，那么mfc会获得+3的好感度。

> mfc的好感度初始为0，且好感度可以叠加，现在给出你一个图形，你需要判断，这个图形能够给mfc带来多少的好感度。

​        （注意，空格可以近似理解为白纸，不属于图形，在考虑对称的时候要予以忽视）

#### 输入

> 一个整数n，表示后续输入有n行，n<=100
>
> 接下来n行字符串，表示白纸上的状态，如果为空格字符，则说明白纸上此处无字，如果为非空格字符，说明此处有一个图案。
>
> 注意，某一行可能是全部由空格组成的字符串。
>
> 每行字符串长度小于100。

#### 输出

> 一个整数，表示该图形得分

#### 样例输入 复制

```plain
样例输入1:
4
   
***
***
***

样例输入2:
2
* *
A A

样例输入3:
2
   A* 
   A*
```

#### 样例输出 复制

```plain
样例输出1:
6

样例输出2:
1

样例输出3:
2
```

#### 提示

> 样例1中：
>
> 输入第一行为空格字符串，表示空白区域，读入后应予以忽视。
>
> 第二到四行组成的图形，显然既沿 平行于Y轴的线对称、又沿 平行于X轴的线对称，同时也是中心对称，故得分为1+2+3=6分。
>
> 
>
> 样例2中：
>
> 输入包含两行，均为有意义的字符串，其中每行的第二个字符均为空格。
>
> 显然仅通过观察，内部的空白字符不影响图案的对称性，即可判断，该图形沿 平行于Y轴的线对称，故得分为1分。
>
> 
>
> 样例3中：
>
> 输入包含两行，均为有意义的字符串，其中每行字符串的前3个字符均为空格。
>
> 显然，开头的空白字符其含义是白纸的空白区域，并非我们判断的图形区域，予以忽略。
>
> 对应的图形区域，为沿 平行于X轴的线对称图形，故得分为2分。







# 问题 E: 更大的整数

#### 题目描述

本题需要你按要求完成类的构建，参考例题

[P1516 - Circle - TJUOJ (chaosheng.top)](http://tjuacm.chaosheng.top/problem.php?id=1516)





mfc在学习C++基础类型的时候就直觉性得意识到他需要一个更强的整数类。

注意：你只需要考虑非负情况！在测试时也将保证不会出现负数。在减法中结果也不会为负数。

目前已有的整数类仍有一些缺陷，例如int的存储范围为 [-2^31, 2^31 - 1]。因此mfc希望实现MyInteger类，并可以高效地实现部分操作。你需要实现的操作有：

构造函数: 

> MyInteger()  //默认构造很熟构造函数, 默认值为0
>
> MyInteger(string& num) // 构造函数，从字符符串构造为大整数。
>
> MyInteger(int num) // 构造函数，从整型构造为大整数。
>
> ~MyInteger()  // 析构函数

成员函数:

string getnum()  // 返回表示大整数的字符字符串，注意去除前导零。

例:

MyInteger bint(123);

cout << bint.getnum() << endl;

// will output "123"

MyInteger bint("01895");
cout << bint.getnum() << endl;
// will output "1895"

MyInteger operator+(const MyInteger& bint2) //大整数加法

MyInteger operator-(const MyInteger& bint2)  //大整数减法

MyInteger operator-(const MyInteger& bint2)  //大整数乘法

**一些提示：**

**为什么需要这么费力得去做这件事？**

像题目说的，整数在使用时无法覆盖所有需要“数字”的情况，如果我们将整数看作是“类”，以面向对象的角度去完善它，即以接口的方式实现整数，我们就可以获得通用性更强的整数类“MyInteger”。在java和python等更高级的语言中，语言的开发人员往往已经帮忙做好了这件事，然而在C++中你需要自己来实现这些操作。

**评测机将会如何测试我的程序？**

教师和助教团队会制作测试数据来分别测试各个函数，对于这道题来说，会按照顺序测试以下函数：

\1. getnum 函数 (20pts)

\2. 加法重载  (30pts)

\3. 减法重载  (30pts)

\4. 乘法重载  (20pts)

例如在测试加法的重载时，我们将会创造两个实例MyInteger bia("1234"), bib("4321"), 测试bia+bib的结果是否为 "5555"。

你可以用你喜欢的方式去实现这个程序，只需要注意保证时间复杂度及空间复杂度，注意不要发生内存泄漏问题。

**其它提示？**

以下友情提示来自智算学部优秀学子孟队长：

对于该题完全可以自由发挥，如果你认为string或者char*不便于你管理内存空间，当然可以尝试使用vector等STL结构辅助进行编程。在实现过程中注意各个代码的底层原理，避免写出时间复杂度过高或空间复杂度过高的代码。使用动态内存分配的同学注意避免内存泄漏。孟学长非常好心地帮你补全了私有成员变量，但是你也可以选择其它你想要的写法。

class MyInteger{

private:

​    string num;

public:

​    //balabala

};





# 问题 F: 小m手环开发者



#### 题目描述



本题需要你按要求完成类的构建，参考例题

[P1516 - Circle - TJUOJ (chaosheng.top)](http://tjuacm.chaosheng.top/problem.php?id=1516)





mfc紧随时代潮流和电子产品的迭代，他有各种各样品牌的运动手环。mfc理想远大，认为在将来的某一天，他也能成立小m公司，并推出小m手环产品，为此他开始思考手环是如何实现这些功能的。



不管是面向过程的程序设计语言、面向对象的程序设计语言甚至是事务性的编程语言与函数式编程语言都可以实现上述的功能，本题需要使用面向对象的编程语言对此功能进行实现，体会面向对象特性对程序设计带来的优势。



mfc对手环产品进行了如下思考：



如果使用面向对象实现手环功能，手环的主要功能之一是记录各种各样的运动，例如骑行、跑步等。不同的运动需要统一的接口，例如将运动转化为运动量，生成记录描述等。



mfc说干就干，他已经完成了基类Sport，现在需要你接着完成子类SportRun和子类SportBicycle。



回忆在学习面向对象编程时“继承”和“多态”是两个非常重要的概念，也是这两个概念让代码的复用变得非常方便，mfc的基类是按照如下方法定义的：



```cpp
class Sport{
protected:
   int minutes, level;
public:
   Sport(int minutes, int level):
       minutes(minutes),
       level(level){
   }
   virtual string getDescription() = 0;
   virtual int getSportIntensity() = 0;
};
```





可以发现两个函数被定义为了纯虚函数，如果你想向小m手环中加入新的运动，则需要实现两个端口。



在主程序中，仅需要



```cpp
   Sport *sp = new Sportxxx();
   sp -> getDescription();
```





即可轻松实现函数的运行期绑定。



下面对两个子类进行说明：



Part 1. class SportRun

getDescrption 将返回一个字符串，表示对于运动过程的描述。

返回格式:    You're running for %d minute(s)

其中%d表示SportRun实例在构造时传入的分钟数。



getSportIntensity 将返回一个整数，表示通过该运动获得的“活力值”

跑步运动的“活力值”计算方式为：

[minutes/10] × level

其中中括号表示取整。



Part 2. class SportBicycle

getDescrption 将返回一个字符串，表示对于运动过程的描述。

返回格式:    You're riding for %d minute(s)

其中%d表示SportBicycle实例在构造时传入的分钟数。



getSportIntensity 将返回一个整数，表示通过该运动获得的“活力值”

跑步运动的“活力值”计算方式为：

[minutes/5]^2 × level

其中中括号表示取整。

点击“提交本题“可以看到mfc为你留下的待补全代码的框架。









# 问题 G: 卡牌大师

#### 题目描述

> mfc是一个很优秀的同学，他学习认真，经常刷题，偶尔也会打打游戏来放松。mfc最喜欢卡牌类型游戏24点。

​          

游戏的规则是：你会被分配抽取N张扑克牌，分别从A-K，其中我们规定牌面为A的牌，其数值为1点；牌面为J、Q、K的牌，其数值分别为11、12、13点；数字牌的点数与其所表示的数字一致。现在你可以通过移动这N张牌的任意次序，并在两两之间插入四种运算符号+、-、*、\（注：除法在这里仅考虑整除的情况，例如3/2=1，4/2=2）。经过上述操作后，我们按照运算顺序计算表达式的结果，如果结果恰好凑成24点，则游戏取得胜利。

> 现在，你被要求和卡牌大师mfc进行一局游戏，因此你需要实现一个程序来帮助你解决如下问题：

> 当你读入N张牌和其对应的数值，你有多少种方法能够恰好凑出24点，并且要输出每种方法的具体情况。

> 我们规定：两种方法不同，当且仅当对应的两个表达式字符串不同。

​          例如：给出的5张牌为、、、、1、2、31、32、5，其中有两个数值3的牌，为了加以区分，我们暂时用下标来进行区分，但在实际测试数据中不会有任何区分。此时，方案1+2∗31∗32+5和方案1+2∗32∗31+5是完全相同的解，在结果中只需要输出一次。

#### 输入

> 输入包括两行，第一行一个整数N，代表卡牌数量，保证N<=6
>
> 第二行输入N个整数，依次表示卡牌的数值。

#### 输出

> 输出每种可能的方案，按照字符串格式输出，计算数与符号之间不需要加空格。
>
> 最后一行输出一个整数，表示可行的解的数量。

#### 样例输入 复制

```plain
4
10 2 13 6 
```

#### 样例输出 复制

```plain
6+10/2+13
6+13+10/2
10/2+6+13
10/2+13+6
13+6+10/2
13+10/2+6
6
```

#### 提示

> 本题考查的重点为：**表达式求值问题**

​          常见的解法有两种，一种是使用递归实现的主符号法、一种是使用栈进行模拟，转成逆波兰表达式进行计算。

两种方法都非常的经典，效率较高，请各位同学自行学习以上两种方法，并选择其中一种方法来实现这道题目，在撰写实验报告时，对两种方法进行对比分析，阐明选择这个算法的逻辑。

> 本题目采用Special Judge方式进行评测，因此在输出方案时，不需要考虑顺序的问题。输出顺序与样例不一致不会使程序产生错误。









# 问题 H: 矩阵内的点

mfc是一个很优秀的同学，他学习认真，经常刷题。这天，他正好学习到了数据离散化与二位前缀和的相关概念，并给大家进行科普。

**数据的离散化**：有些数据本身很大，自身无法作为数组的下标保存对应的属性。如果这时只是需要这堆数据的相对属性，那么可以对其进行离散化处理。当数据只与它们之间的相对大小有关，而与具体是多少无关时，可以进行离散化。                                                    ——百度百科

例如： 设有4个数：

1234567、123456789、12345678、123456

排序：123456<1234567<12345678<123456789

=>1<2<3<4

那么这4个数可以表示成：2、4、3、1                 

实现离散化的方法有很多，大家可以自行学习。

**二位前缀和：**定义一个二维数组s[][]，s[i][j]表示二维数组中，左上角(1, 1)到右下角(i, j)所包围的矩阵元素的和。如下图所示：

![img](http://xjudge.online/upload/tjuacm.chaosheng.top/image/20221203/20221203000710_83693.png)

![img](http://xjudge.online/upload/tjuacm.chaosheng.top/image/20221203/20221203000729_73329.png)

**二维前缀和的推导公式：**整个外围蓝色矩形面积s[i][j]=绿色面积s[i - 1][j] + 紫色面积s[i][j - 1] - 重复加的红色的面积s[i - 1][j - 1] + 小方块的面积a[i][j]。



**使用二位前缀和求解矩阵的面积：**求以(x1,y1)为左上角和以(x2,y2)为右下角的矩阵的元素的和。

![img](http://xjudge.online/upload/tjuacm.chaosheng.top/image/20221203/20221203000804_41760.png)

![img](http://xjudge.online/upload/tjuacm.chaosheng.top/image/20221203/20221203000820_24574.png)

绿色矩形的面积 S = 整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - 1] - 紫色面积s[x1 - 1, y2] + 重复减去的红色面积 s[x1 - 1, y1 - 1]。

当你认真听取m队长给你讲述的知识后，脑洞大开，决定利用所学内容解决下述问题。在一张无限大二维网格上，存在n(n<=5000)个点，点i(0<=i<n)坐落在(xi,yi)格子上。当我们任取两个点，都可以以这两个点构成一个矩形（注意：当两个点横坐标相同或纵坐标相同时退化成一条宽为1的网格条，两个点是同一坐标时退化成一个网格，这并不影响我们的任务），我们的任务是求出这个矩形内存在多少个点？

#### 输入

第一行输入两个整数n,m表示网格上分布着n个点，同时我们有m个矩形需要统计内部的点的数量。

接下来n行，每行两个整数x,y表示点i(0<=i<n)的坐标。

接下来m行，每行两个整数k1,k2（0<=k1,k2<n），表示我们查询以点k1和点k2构成的矩形内点的数量。





#### 输出

m行，每行一个整数，表示第i次询问的矩形内部的点的数量。

#### 样例输入 复制

```plain
4 3
0 0
0 1
1 0
1 1
0 3
0 1
2 2
```

#### 样例输出 复制

```plain
4
2
1
```

#### 提示

一共四个点，分布在(0,0),(0,1),(1,0),(1,1)四个网格中，如图所示：、

![img](http://xjudge.online/upload/tjuacm.chaosheng.top/image/20221203/20221203000929_62088.png)



三次询问，0号点和3号点构成的矩形以(O,0)为左上角，(1,1)为右下角，内部包含4个点。

0号点和1号点构成的矩形以（0，0）为左上角，（0，1）为右下角，内部包含2个点。

2号点和2号点构成的矩形只有（1，0）一个格子，内部包含1个点。

**重要提示：**

​        保证60%的数据中，点的数量n<=100，查询的次数m<=100，并且所有点的坐标都在[1,100]以内，也就是说你完全可以不听取m队长的任何建议就可以得到本题目60%的分数。

​        保证80%的数据中，点的数量n<=5000，查询的次数m<=10000，并且所有点的坐标都在[1,1000]以内，也就是说你只需要听会m队长的二维前缀和就可以得到本题目80%的分数。

​        保证100%的数据中，点的数量n<=5000，查询的次数m<=100000，并且所有点的坐标在int表示的范围内即[-231,231-1]，也就是说你既需要学会m队长讲的离散化也要学会二位前缀和才可以得到本题目100%的分数。





